// ============================================
// Promise 原理详解
// ============================================

/*
一、Promise 是什么？

Promise 是一个"状态机"，用来管理异步操作的状态。
它解决了传统回调函数的"回调地狱"问题。
*/

// ============================================
// 1. Promise 的三种状态
// ============================================

/*
┌─────────────┐
│   Pending   │  初始状态（进行中）
│  （待定）    │
└──────┬──────┘
       │
       ├──────────┐
       │          │
       ▼          ▼
┌──────────┐  ┌──────────┐
│Fulfilled │  │ Rejected │
│ （成功）  │  │ （失败）  │
└──────────┘  └──────────┘

重要特性：
1. 状态只能从 Pending → Fulfilled 或 Pending → Rejected
2. 状态一旦改变，就不能再变（不可逆）
3. 状态改变后，结果会被永久保存
*/

// ============================================
// 2. Promise 的基本结构
// ============================================

// 创建一个最简单的 Promise
const promise1 = new Promise((resolve, reject) => {
  // executor 函数（执行器）
  // 这个函数会立即同步执行
  
  console.log('Promise 内部代码立即执行');
  
  // resolve: 将状态改为 Fulfilled
  // reject: 将状态改为 Rejected
});

console.log('Promise 创建完成');

// 输出顺序：
// 1. "Promise 内部代码立即执行"
// 2. "Promise 创建完成"


// ============================================
// 3. resolve 和 reject 的作用
// ============================================

console.log('\n===== resolve 和 reject 示例 =====');

// 成功的 Promise
const successPromise = new Promise((resolve, reject) => {
  console.log('1. 开始异步操作');
  
  setTimeout(() => {
    console.log('2. 异步操作完成');
    resolve('成功的结果'); // 改变状态为 Fulfilled，并保存结果
  }, 100);
});

// 使用 .then() 获取结果
successPromise.then((result) => {
  console.log('3. 收到结果:', result);
});

// 失败的 Promise
setTimeout(() => {
  const failPromise = new Promise((resolve, reject) => {
    console.log('\n4. 开始可能失败的操作');
    
    const success = false;
    if (success) {
      resolve('成功');
    } else {
      reject('失败原因'); // 改变状态为 Rejected，并保存错误
    }
  });
  
  failPromise
    .then((result) => {
      console.log('成功:', result);
    })
    .catch((error) => {
      console.log('5. 捕获错误:', error);
    });
}, 200);


// ============================================
// 4. Promise 的执行时序
// ============================================

setTimeout(() => {
  console.log('\n===== Promise 执行时序 =====');
  
  console.log('1. 同步代码开始');
  
  const promise = new Promise((resolve, reject) => {
    console.log('2. Promise 构造函数内部（同步执行）');
    
    setTimeout(() => {
      console.log('4. setTimeout 回调（异步执行）');
      resolve('结果');
    }, 0);
    
    console.log('3. Promise 构造函数内部结束');
  });
  
  promise.then((result) => {
    console.log('5. then 回调（微任务）');
  });
  
  console.log('6. 同步代码结束');
  
  /*
  输出顺序：
  1. 同步代码开始
  2. Promise 构造函数内部（同步执行）
  3. Promise 构造函数内部结束
  6. 同步代码结束
  5. then 回调（微任务）
  4. setTimeout 回调（宏任务）
  
  原因：微任务优先于宏任务
  */
}, 400);


// ============================================
// 5. Promise 的内部机制（简化版）
// ============================================

setTimeout(() => {
  console.log('\n===== Promise 内部机制模拟 =====');
  
  // 这是一个简化的 Promise 实现，帮助理解原理
  class SimplePromise {
    // 内部状态
    private state: 'pending' | 'fulfilled' | 'rejected' = 'pending';
    // 保存的结果
    private value: any = undefined;
    // 保存的错误
    private reason: any = undefined;
    // 成功回调队列
    private onFulfilledCallbacks: Array<(value: any) => void> = [];
    // 失败回调队列
    private onRejectedCallbacks: Array<(reason: any) => void> = [];
    
    constructor(executor: (resolve: Function, reject: Function) => void) {
      console.log('  → Promise 构造函数执行');
      
      // resolve 函数的实现
      const resolve = (value: any) => {
        // 只有在 pending 状态才能改变
        if (this.state === 'pending') {
          console.log('  → resolve 被调用，状态: pending → fulfilled');
          this.state = 'fulfilled';
          this.value = value;
          
          // 执行所有成功回调
          this.onFulfilledCallbacks.forEach(fn => fn(value));
        }
      };
      
      // reject 函数的实现
      const reject = (reason: any) => {
        if (this.state === 'pending') {
          console.log('  → reject 被调用，状态: pending → rejected');
          this.state = 'rejected';
          this.reason = reason;
          
          // 执行所有失败回调
          this.onRejectedCallbacks.forEach(fn => fn(reason));
        }
      };
      
      // 立即执行 executor
      try {
        executor(resolve, reject);
      } catch (error) {
        reject(error);
      }
    }
    
    // then 方法的实现
    then(onFulfilled?: (value: any) => void, onRejected?: (reason: any) => void) {
      console.log('  → then 方法被调用');
      
      // 如果已经是 fulfilled 状态，立即执行回调
      if (this.state === 'fulfilled' && onFulfilled) {
        setTimeout(() => onFulfilled(this.value), 0);
      }
      
      // 如果已经是 rejected 状态，立即执行回调
      if (this.state === 'rejected' && onRejected) {
        setTimeout(() => onRejected(this.reason), 0);
      }
      
      // 如果还是 pending 状态，将回调存入队列
      if (this.state === 'pending') {
        if (onFulfilled) {
          this.onFulfilledCallbacks.push(onFulfilled);
        }
        if (onRejected) {
          this.onRejectedCallbacks.push(onRejected);
        }
      }
      
      return this;
    }
    
    catch(onRejected: (reason: any) => void) {
      return this.then(undefined, onRejected);
    }
  }
  
  // 测试我们的 SimplePromise
  console.log('创建 SimplePromise:');
  const myPromise = new SimplePromise((resolve, reject) => {
    console.log('  → executor 函数执行');
    setTimeout(() => {
      console.log('  → 异步操作完成');
      resolve('自定义Promise的结果');
    }, 100);
  });
  
  myPromise.then((result) => {
    console.log('  → then 回调执行，结果:', result);
  });
}, 600);


// ============================================
// 6. resolve 和 reject 的深入理解
// ============================================

setTimeout(() => {
  console.log('\n===== resolve 和 reject 深入理解 =====');
  
  // resolve 做了什么？
  console.log('\nresolve 的作用：');
  const p1 = new Promise((resolve, reject) => {
    console.log('1. Promise 内部开始执行');
    console.log('2. 调用 resolve("数据")');
    resolve('数据');
    console.log('3. resolve 调用后继续执行');
    console.log('4. 注意：状态已经改变，但 then 还没执行');
  });
  
  p1.then((data) => {
    console.log('5. then 回调执行，拿到数据:', data);
  });
  
  console.log('6. Promise 外部的同步代码');
  
  /*
  resolve 的作用：
  1. 将 Promise 状态从 pending 改为 fulfilled
  2. 保存传入的值
  3. 触发所有 then 注册的成功回调（异步执行）
  */
}, 800);


// ============================================
// 7. Promise 与事件循环
// ============================================

setTimeout(() => {
  console.log('\n===== Promise 与事件循环 =====');
  
  console.log('1. 同步代码');
  
  setTimeout(() => {
    console.log('4. 宏任务：setTimeout');
  }, 0);
  
  Promise.resolve().then(() => {
    console.log('3. 微任务：Promise.then');
  });
  
  console.log('2. 同步代码结束');
  
  /*
  执行顺序解释：
  
  调用栈（同步）:
    ↓ 1. 同步代码
    ↓ 2. 同步代码结束
    ↓ 清空
  
  微任务队列（优先）:
    ↓ 3. Promise.then
    ↓ 清空
  
  宏任务队列:
    ↓ 4. setTimeout
  
  规则：每个宏任务执行完后，会清空所有微任务
  */
}, 1000);


// ============================================
// 8. Promise 的链式调用原理
// ============================================

setTimeout(() => {
  console.log('\n===== Promise 链式调用原理 =====');
  
  // then 方法返回新的 Promise
  const p = Promise.resolve(1);
  
  p.then((value) => {
    console.log('第一个 then:', value); // 1
    return value + 1; // 返回值会被包装成 Promise
  })
  .then((value) => {
    console.log('第二个 then:', value); // 2
    return value + 1;
  })
  .then((value) => {
    console.log('第三个 then:', value); // 3
  });
  
  /*
  链式调用原理：
  1. then 方法返回一个新的 Promise
  2. 回调的返回值会成为下一个 Promise 的值
  3. 如果返回的是 Promise，会等待它完成
  */
}, 1200);


// ============================================
// 9. 完整的 Promise 生命周期
// ============================================

setTimeout(() => {
  console.log('\n===== Promise 完整生命周期 =====');
  
  console.log('步骤1: 创建 Promise');
  const lifecycle = new Promise((resolve, reject) => {
    console.log('步骤2: executor 立即执行（同步）');
    console.log('  - 此时状态: pending');
    
    setTimeout(() => {
      console.log('步骤3: 异步操作完成');
      console.log('  - 调用 resolve()');
      resolve('最终结果');
      console.log('  - 状态变为: fulfilled');
      console.log('  - 结果被保存');
    }, 50);
  });
  
  console.log('步骤4: 注册 then 回调');
  lifecycle.then((result) => {
    console.log('步骤5: then 回调执行（微任务）');
    console.log('  - 收到结果:', result);
  });
  
  console.log('步骤6: 同步代码继续执行');
}, 1400);


// ============================================
// 10. 关键概念总结
// ============================================

/*
Promise 内部机制总结：

1. 状态管理
   - 三种状态：pending、fulfilled、rejected
   - 状态只能改变一次
   - 状态改变后，结果被永久保存

2. executor 函数
   - 创建 Promise 时立即同步执行
   - 接收 resolve 和 reject 两个函数

3. resolve 函数
   - 改变状态：pending → fulfilled
   - 保存成功的结果
   - 触发 then 的成功回调（异步）

4. reject 函数
   - 改变状态：pending → rejected
   - 保存失败的原因
   - 触发 catch 的失败回调（异步）

5. then 方法
   - 注册成功和失败的回调
   - 返回新的 Promise（支持链式调用）
   - 回调函数异步执行（微任务）

6. 与事件循环的关系
   - executor 同步执行
   - then/catch 回调是微任务
   - 微任务优先于宏任务（setTimeout）

7. 回调队列
   - Promise 内部维护回调队列
   - 状态改变时，依次执行队列中的回调
   - 如果注册回调时已经完成，立即（异步）执行

8. 不可逆性
   - resolve/reject 只有第一次调用有效
   - 后续调用会被忽略
   - 保证结果的确定性
*/


// ============================================
// 11. 实战示例：理解 Promise 原理
// ============================================

setTimeout(() => {
  console.log('\n===== 实战示例 =====');
  
  // 示例：包装 setTimeout
  function delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
      console.log(`创建延迟 ${ms}ms 的 Promise`);
      setTimeout(() => {
        console.log(`${ms}ms 后调用 resolve`);
        resolve();
      }, ms);
    });
  }
  
  console.log('开始');
  delay(100).then(() => {
    console.log('延迟完成');
  });
  console.log('继续执行');
}, 1600);


// ============================================
// 12. 常见误区
// ============================================

setTimeout(() => {
  console.log('\n===== 常见误区 =====');
  
  // 误区1：以为 new Promise 会等待
  console.log('\n误区1: new Promise 不会等待');
  new Promise((resolve) => {
    setTimeout(() => resolve(), 100);
  });
  console.log('不会等待，立即执行到这里');
  
  // 误区2：多次调用 resolve
  setTimeout(() => {
    console.log('\n误区2: 多次调用 resolve 只有第一次有效');
    new Promise((resolve) => {
      resolve('第一次');
      resolve('第二次'); // 无效
      resolve('第三次'); // 无效
    }).then((value) => {
      console.log('只会输出:', value); // "第一次"
    });
  }, 100);
  
  // 误区3：以为 then 是同步的
  setTimeout(() => {
    console.log('\n误区3: then 回调是异步的');
    Promise.resolve('立即完成的Promise').then((value) => {
      console.log('2. then 回调（微任务）');
    });
    console.log('1. 同步代码先执行');
  }, 200);
}, 1800);


// ============================================
// Promise 原理可视化详解
// ============================================

# Promise 原理可视化讲解

## 一、Promise 的核心：状态机

```
创建时                异步操作              最终状态
  │                     │                    │
  ▼                     ▼                    ▼
┌─────────┐         ┌─────────┐         ┌─────────┐
│ Pending │────────→│ Pending │────────→│Fulfilled│
│ (待定)  │         │ (进行中)│         │ (成功)  │
└─────────┘         └─────────┘         └─────────┘
                         │
                         │ 如果失败
                         ▼
                    ┌─────────┐
                    │Rejected │
                    │ (失败)  │
                    └─────────┘
```

## 二、new Promise() 内部发生了什么

### 步骤分解

```javascript
const promise = new Promise((resolve, reject) => {
  // 这里的代码
});
```

### 执行流程

```
时间线：  0ms         1ms         2ms         3ms
         │           │           │           │
         ▼           ▼           ▼           ▼
     
1. 创建 Promise 对象
   │
   ├─ 初始化状态：pending
   ├─ 初始化值：undefined
   ├─ 创建回调队列：[]
   │
   └─→ 立即执行 executor 函数 ────────┐
                                      │
2. executor 函数内部                   │
   ├─ 同步代码立即执行 ←──────────────┘
   ├─ 遇到 setTimeout
   │   └─→ 放入宏任务队列
   │
   └─→ executor 执行完毕
   
3. Promise 创建完成
   │
   └─→ 返回 Promise 对象

4. 事件循环继续
   │
   ├─→ 执行微任务队列
   │
   └─→ 执行宏任务队列
       └─→ setTimeout 触发
           └─→ 调用 resolve()
               ├─ 状态：pending → fulfilled
               ├─ 保存值
               └─ 触发 then 回调
```

## 三、resolve() 的内部机制

```javascript
// 简化的 resolve 实现
function resolve(value) {
  // 1. 检查状态
  if (this.state !== 'pending') {
    return; // 已经改变过了，直接返回
  }
  
  // 2. 改变状态
  this.state = 'fulfilled';
  
  // 3. 保存值
  this.value = value;
  
  // 4. 触发所有成功回调
  this.onFulfilledCallbacks.forEach(callback => {
    // 异步执行（微任务）
    queueMicrotask(() => callback(value));
  });
}
```

### 可视化流程

```
调用 resolve('结果')
    │
    ▼
┌─────────────────────────────────┐
│ 1. 检查当前状态                  │
│    if (state !== 'pending')     │
│        return;                  │
└────────────┬────────────────────┘
             │ 状态是 pending
             ▼
┌─────────────────────────────────┐
│ 2. 改变状态                      │
│    state = 'fulfilled'          │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 3. 保存结果                      │
│    value = '结果'               │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 4. 遍历回调队列                  │
│    callbacks.forEach(fn => {    │
│      queueMicrotask(() =>       │
│        fn(value)                │
│      )                          │
│    })                           │
└────────────┬────────────────────┘
             │
             ▼
      微任务队列中等待执行
```

## 四、完整的执行流程示例

```javascript
console.log('1. 开始');

const promise = new Promise((resolve, reject) => {
  console.log('2. executor 执行');
  
  setTimeout(() => {
    console.log('5. setTimeout 回调');
    resolve('结果');
    console.log('6. resolve 调用完成');
  }, 0);
  
  console.log('3. executor 结束');
});

promise.then((value) => {
  console.log('7. then 回调:', value);
});

console.log('4. 结束');
```

### 时间线和任务队列

```
时间轴：━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

0ms  │ 调用栈                  │ 微任务队列  │ 宏任务队列
     │ ▼                      │            │
     │ console.log('1. 开始') │            │
     │ ▼                      │            │
     │ new Promise()          │            │
     │   ▼                    │            │
     │   executor 执行         │            │
     │   ▼                    │            │
     │   console.log('2')     │            │
     │   ▼                    │            │
     │   setTimeout()         │            │ ← [setTimeout回调]
     │   ▼                    │            │
     │   console.log('3')     │            │
     │ ▼                      │            │
     │ promise.then()         │            │
     │   (注册回调)            │            │
     │ ▼                      │            │
     │ console.log('4. 结束') │            │
     │ ▼                      │            │
     │ 调用栈清空              │            │
     ├────────────────────────┼────────────┼──────────
     │                        │ (空)       │
     ├────────────────────────┼────────────┼──────────
1ms  │ 执行宏任务              │            │
     │ ▼                      │            │
     │ setTimeout 回调         │            │ ← 出队
     │ ▼                      │            │
     │ console.log('5')       │            │
     │ ▼                      │            │
     │ resolve('结果')        │            │
     │   状态改变              │            │
     │   触发 then 回调        │ → [then回调] │
     │ ▼                      │            │
     │ console.log('6')       │            │
     │ ▼                      │            │
     │ 调用栈清空              │            │
     ├────────────────────────┼────────────┼──────────
     │ 执行微任务              │            │
     │ ▼                      │            │
     │ then 回调              │ ← 出队     │
     │ ▼                      │            │
     │ console.log('7')       │            │
     │ ▼                      │            │
     │ 完成                   │            │

输出顺序：
1. 开始
2. executor 执行
3. executor 结束
4. 结束
5. setTimeout 回调
6. resolve 调用完成
7. then 回调: 结果
```

## 五、Promise 内部数据结构

```javascript
// Promise 内部的简化数据结构
class Promise {
  // 状态
  [[PromiseState]]: 'pending' | 'fulfilled' | 'rejected'
  
  // 结果
  [[PromiseResult]]: any
  
  // 回调队列
  [[OnFulfilledCallbacks]]: Function[]
  [[OnRejectedCallbacks]]: Function[]
}
```

### 状态变化图

```
创建时：
┌──────────────────────┐
│ state: 'pending'     │
│ result: undefined    │
│ callbacks: []        │
└──────────────────────┘

调用 resolve('数据') 后：
┌──────────────────────┐
│ state: 'fulfilled'   │  ← 状态改变
│ result: '数据'       │  ← 保存结果
│ callbacks: []        │  ← 回调已执行并清空
└──────────────────────┘
```

## 六、为什么需要 await

```javascript
// 没有 await
new Promise((resolve) => {
  setTimeout(() => resolve('结果'), 100);
});
console.log('立即执行'); // 不等待

// 有 await
await new Promise((resolve) => {
  setTimeout(() => resolve('结果'), 100);
});
console.log('等待 100ms 后执行'); // 等待
```

### 执行对比

```
没有 await：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
0ms   | new Promise()
      | Promise 创建完成
      | console.log() ✓
      | 继续执行下面的代码...
      |
100ms | [Promise 内部才完成，但没人等]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

有 await：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
0ms   | await new Promise()
      | ⏸️  暂停执行
      | [等待中...]
      |
100ms | resolve() 被调用
      | ▶️  恢复执行
      | console.log() ✓
      | 继续执行下面的代码...
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

## 七、核心概念总结

### 1. Promise 是状态机
- 管理异步操作的状态
- 状态只能改变一次
- 状态改变后结果被保存

### 2. executor 立即执行
- 创建 Promise 时同步执行
- 不需要等待任何东西
- 内部的异步操作会放入队列

### 3. resolve/reject 改变状态
- 从 pending 变为 fulfilled/rejected
- 保存结果或错误
- 触发对应的回调

### 4. then 注册回调
- 如果已完成，回调会异步执行
- 如果未完成，回调会被存储
- 返回新 Promise 支持链式调用

### 5. 微任务执行
- then/catch 回调是微任务
- 优先于宏任务执行
- 确保异步但快速执行

### 6. await 等待完成
- 暂停当前函数执行
- 等待 Promise 状态改变
- 获取结果后继续执行

## 八、记忆要点

```
┌─────────────────────────────────────┐
│  new Promise()                      │
│  ├─ 创建：同步                       │
│  ├─ executor：立即执行               │
│  └─ 返回：不等待                     │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  resolve()/reject()                 │
│  ├─ 改变状态：只能一次               │
│  ├─ 保存结果：永久保存               │
│  └─ 触发回调：异步执行               │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  .then()                            │
│  ├─ 注册回调：可多次调用             │
│  ├─ 执行时机：微任务                 │
│  └─ 返回值：新 Promise              │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  await                              │
│  ├─ 作用：等待 Promise              │
│  ├─ 暂停：当前函数                   │
│  └─ 恢复：状态改变后                 │
└─────────────────────────────────────┘
```
